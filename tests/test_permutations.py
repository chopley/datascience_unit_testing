from unittest import TestCase

import numpy as np
import pandas as pd


def generate_simulated_data(n_samples, repayment_percentages):
    from statistics.permutation import generate_simulated_repayments

    billed_amounts = np.random.pareto(6, n_samples) * 1000
    repayment_choices = [0, 1]
    repayment_percentages = repayment_percentages
    repayments = generate_simulated_repayments(
        repayment_choices, repayment_percentages, billed_amounts
    )
    return (billed_amounts, repayments)


def return_test_dataframe(n_samples, repayment_percentages, arm_name, time_passed):
    """

    :param n_samples: number of samples per time point
    :param repayment_percentages: probability of repyment vs non repayment
    :param arm_name: name of the
    :param time_passed:
    :return:
    billed_during : list of values that were generated by Pareto distribution.
    collected_during : list of values were generated by probabilistic collections.
    """
    (billed_during, collected_during) = generate_simulated_data(
        n_samples, repayment_percentages
    )
    test_data = pd.DataFrame(
        {
            "experimental_arm": arm_name,
            "collected_during": collected_during,
            "billed_during": billed_during,
            "time_passed": time_passed,
        }
    )
    return test_data


def return_concat_dataframe(n_samples, time_repayment_percentages):
    """
    :param n_samples:
    :param time_repayment_percentages: dictionary with parameters used to generate the simulation sample

    :return: dataframe as below
        experimental_arm  collected_during  billed_during  time_passed
                one         43.339423      43.339423           15
                one        478.028280     478.028280           15
                one         99.115673      99.115673           15
               three          0.000000      19.796614           60
               three          0.000000     213.039015           60
               three          0.000000     167.666527           60
    """
    concat_df = pd.DataFrame()
    arms = time_repayment_percentages.keys()
    for arm in arms:
        repayments_percentages = time_repayment_percentages[arm]
        time_values = repayments_percentages.keys()
        for time_value in time_values:
            test_data_dict = return_test_dataframe(
                n_samples, repayments_percentages[time_value], arm, time_value
            )
            if concat_df.empty:
                concat_df = test_data_dict
            else:
                concat_df = concat_df.append(test_data_dict)
    return concat_df


class test_permutations(TestCase):
    """
    This is the test class for the permutations testing library written for Cedar experiments
    """

    def setUp(self):
        """
        Here we set up the data that will be used for the test procedure.

        Firstly, the test data are generated from a Pareto distribution with sufficient sample size that the statistics are
        reproducible.

        """
        # first set up the test data that will be used-
        self.repayments = {
            "one": {15: [0.2, 0.8], 30: [0.3, 0.7], 45: [0.4, 0.6], 60: [0.5, 0.5]},
            "two": {15: [0.2, 0.8], 30: [0.3, 0.7], 45: [0.4, 0.6], 60: [0.5, 0.5]},
            "three": {15: [0.2, 0.8], 30: [0.4, 0.60], 45: [0.5, 0.5], 60: [0.7, 0.3]},
            "four": {15: [0.2, 0.8], 30: [0.3, 0.7], 45: [0.5, 0.5], 60: [0.55, 0.45]},
        }

    def test_group_one(self):
        """
         These two samples are generated from identical repayment percentages. There should be no difference between them
         """
        concat_df = return_concat_dataframe(1000, self.repayments)
        from statistics.permutation import permutation_test as permutation_test

        time_column = "time_passed"
        group_columns = ["experimental_arm"]
        values_to_compare = ["one", "two"]

        (
            gT,
            p_val,
            pD,
        ) = permutation_test.permutation_test_statistic_time_series(
            concat_df,
            200,
            permutation_test.get_collection_rate,
            time_column=time_column,
            group_columns=group_columns,
            group_values=values_to_compare,
        )

        self.assertGreater(p_val, 0.2)

    def test_group_two(self):
        """
        These two samples are generated from different repayment percentages. There should be a statistical difference
        """

        concat_df = return_concat_dataframe(1000, self.repayments)
        from statistics.permutation import permutation_test as permutation_test

        time_column = "time_passed"
        group_columns = ["experimental_arm"]
        values_to_compare = ["one", "three"]

        (
            gT,
            p_val,
            pD,
        ) = permutation_test.permutation_test_statistic_time_series(
            concat_df,
            200,
            permutation_test.get_collection_rate,
            time_column=time_column,
            group_columns=group_columns,
            group_values=values_to_compare,
        )
        self.assertLess(p_val, 0.05)

    def test_group_three(self):
        """
        These two samples are generated from different repayment percentages. There should be a statistical difference
        """

        concat_df = return_concat_dataframe(1000, self.repayments)
        from statistics.permutation import permutation_test as permutation_test

        time_column = "time_passed"
        group_columns = ["experimental_arm"]
        values_to_compare = ["one", "four"]

        (
            gT,
            p_val,
            pD,
        ) = permutation_test.permutation_test_statistic_time_series(
            concat_df,
            400,
            permutation_test.get_collection_rate,
            time_column=time_column,
            group_columns=group_columns,
            group_values=values_to_compare,
        )
        self.assertLess(p_val, 0.05)
